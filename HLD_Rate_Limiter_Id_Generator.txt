Popular Interview questions :

1.) Id generator : 
	-> Id should be unique
	-> Incremental. Something that is entered in our system earlier should have lower id compared to something entered later.
	-> Need to take care of sharding the DBs, so ids for same table can not have two same ids in to different shards.

	Approaches :
	1.) Single machine assinging ids starting from 1. 
		-> Single machine becomes SPOC
		-> Single Machine is a bootleneck in case of lot of requests.
	2.) UUID/GUID
		-> Unique
		-> Not incremental 
	3.) Give each machine a pattern of ids. 1 Machine is give ids in 3x, 2nd is given 3x+1, 3rd is given 3x + 2.
		-> Unique
		-> Not incremental 
	4.) Use Timestamp only
		->Incremental
		-> Not unique.
	5.) Use unique_number + timestamp
		-> Unique
		-> Not incremental as the ids will first be compared on unique number and then on timestamp so can not guarentee increment for later arrived requests.
	6.> Use timestamp + unique_number
		-> Unique (Small chance that 2 requests come to 1 machine at same time)
		-> Incremental
	7.) Use timestamp + unique machine id + sequence_id(sequence_id is generated by each machine on its own and two machines can have same sequence_ids)
		-> Unique because of sequence_id which is generated on each machine individually  and sequence_id being incremental ensures incremental id.
		-> Incremental
		
	Using the 7th approach. (This is the twitter snowflake approach)
	-> Now first we take the timestamp as a 64 bit long value.
	-> First 42 bits is for the timestamp which will cover us till 2050.
	-> Next 4 bits for datacenter id.
	-> Next 6 bits for the machines in the datacenters.
	-> Remaining 12 bits for sequnce ids.
	
	In these approaches from 2 - 7 we will have each machine generate thier own id without a central system.
	
	This is ensure us that id will be unique if we get less than 4096 requests on 1 machine at the same time. The probability of this is very low.
	
	We can change distribution of bits based on how many datacenters, machines and no. of request we receive.
	
	Why have an incremental id ?
	-> Lot of sytems have a default index on id so searching on id is fast. Delta fetch on time stamp ids is faster.
	
	
2.) Rate Limiter :
	-> DDOS - Distributed Denial Of Service : This is a type of attack where we send a lot of requests to the server which will make the server slow for actual users and this will be a bad experience.
	
	What is a rate limiter ? 
		-> One user, ip address, id, etc should not be able to send me more than x requests per t seconds. This is enforced using a rate limiter to prevent a  DDOS attack.
	
	Where should a rate limiter be running ?
		-> Mostly on gateway and LBs but sometimes on app server.
		-> If we want to prevent DDOS from occuping our server we need to deploy it at the gateway. but gateway could be too heavy ?
		
	Using queue is heavy and might overload the Gateway or LB.
	An approximate approach that is lighter is : create 2 60 secs buckets and store requests received in the 60 second window. and once the 60 secs has passed move this to the previous map and create a new map that stores 60 seconds data. and lets say we receive 5 requests in 20 seconds and we need to check how many requests are received in 60 seconds. If we have received 8 requests in the last 60 seconds so we can approximate the requests in 40 seconds by dividing the total no of requests by the toatl time * time needed.

	This is an approximate appraoch but good for light weight systems.
	
3.) URL shortner :
	orighnal url :	www.google.com 
	shortened url : bitly/xyz
	How is it implemented ? 
	-> A simple map to store shortend url and orignal url map.
	How to generate the hash ?
		-> Could be generated on the timestamp
		-> Could be some random function where we generate using rand() and check if it exists in db. If yes regenrate.
		
	How to allow users to generate custom url :
		-> Just allow users to enter a custom url. If it exists in DB ask to regenerate.
		
